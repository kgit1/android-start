download android studio -> instal -> run

start new Android Studio project

app name : Demo App
company domain: a.example.com
project location: D:\J\android\android-start\DemoApp
next
phone and tablet -> minimum sdk -> Api 15: Android 4.0.3
next -> next -> empty activity -> next -> 
activity name MainActivity + layout name activity_main -> finish

minifests folder
android manifest xml contains basic info about app icon , label, app name, theme, etc

resources folder
hold icons, images, music etc what we for app need

java folder 
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;

//appCompatActivity makes sure that app compatable with as many old android versions as needed
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
}

resources -> layout -> activity_mail.xml - double click -> view on app
green olay button at top center to run app
create new emulator -> phone -> nexus s -> next -> system image - nougat Android 7.1.1 -> next

drag TextView element from Pallete-> Widgets to devices screen, put where needed, change text and
id in properties window, open all propertiesm change margin to 20dp(not px, dp prefered because âo not rely on screen resolution)(sp - scale independed pixel, same as dp, but affected by user zoom level)
use lighting near play to insta run changed build

add button
find onClick in properties -> type clickFunction

create clickFunction in MainActivity class

public void clickFunction(View view){
        System.out.println("Clicked");
        Log.i("Info", "Button pressed");
    }

run app with lightning, click button
see System.out and Log info in Android Monitor

add PlainText(text field)
empty name
change hint to "Enter your name"

change clickFunction to handle text field
create object EditText and assign value from field which we acces by method
findViewById(R.id.myTextField) - R - for resources, id - for elemement id

 public void clickFunction(View view){
        EditText stringEnterName = (EditText) findViewById(R.id.myTextField);
        EditText stringEnterPassword = (EditText) findViewById(R.id.myPasswordField);
        System.out.println("Clicked");
        Log.i("Info", "Button pressed");
        Log.i("Name", stringEnterName.getText().toString());
        Log.i("Password",stringEnterPassword.getText().toString());
    }

add Toast - quick pop-up window
	Toast.makeText(MainActivity.this, "Login: "+stringEnterName.getText().toString(),
        Toast.LENGTH_SHORT).show();
and in method
public void clickFunction(View view){
        EditText stringEnterName = (EditText) findViewById(R.id.myTextField);
        EditText stringEnterPassword = (EditText) findViewById(R.id.myPasswordField);

        Toast.makeText(MainActivity.this, "Login: "+stringEnterName.getText().toString(),
                Toast.LENGTH_SHORT).show();

        Toast.makeText(MainActivity.this, "Password: "+stringEnterPassword.getText().toString(),
                Toast.LENGTH_SHORT).show();

        Toast.makeText(MainActivity.this, "Hi there, Queen of Meereen, Queen of the Andals" +
                "(, the Rhoynar) and the First Men, Lady Regnant of the Seven Kingdoms, Khaleesi"+
                "of the Great Grass Sea, Mhysa, Breaker of Chains, the Unburnt, Mother of Dragons",
                Toast.LENGTH_LONG).show();        

        System.out.println("Clicked");
        Log.i("Info", "Button pressed");
        Log.i("Name", stringEnterName.getText().toString());
        Log.i("Password",stringEnterPassword.getText().toString());
    }
==================================================================

============JAVADOC UNDER CURSOR=====================================
	Android Studio does not displayed Javadoc by default when an element is being hovered, 	which is a burden for productivity. However, this can be easily set up:

	Go to Preferences and then Editor. When the window appears, mark the last option
==================================================================


============DOWNLOAD FROM WEB=====================================
add to AndroidManifest.xml
<uses-permission android:name="android.permission.INTERNET"/>

to be like
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.a.appdownloadfromweb">

    <uses-permission android:name="android.permission.INTERNET"/>

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>

than to handle downloading on side thread, not on main which handles our app ui
create class DownloadTask which extends AsyncTask class with generic params <String,Void,String>
where first - String - data which class constructor will take
      second - Void - name of the method which can show progress of this task
      third - String - variable which will return results of work of DownloadTask class

when we extends AsyncTask class it implements overrided method doInBackground
which takes String and returns String as we desided here -> AsynkTask<String,Void,String>
so it look like
protected String doInBackground(String... params) {}

when we create object of class DownloadTask
and call execute method -> doInBackground() method will be called
and call of get() method after execute method - will make this construction to return result value
so
DownloadTask task = new DownloadTask();
String result = task.execute("some string").get();
so on execute().get() - method doInBackground will be called and return result of his work

next example of apps MainActivite class where DownloadTask class processes string with url adress
and returns data(html code of page found on urls location)

import android.os.AsyncTask;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.util.Log;

//add in AndroidManifest.xml to provide internet use permission
// <uses-permission android:name="android.permission.INTERNET"/>

import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.concurrent.ExecutionException;

public class MainActivity extends AppCompatActivity {

    //AsyncTask allows to run another task behind(in new background thread) MainActivity thread
    // which displays app to user
    // in AsyncTask<?,?,?>
    //first (String) - variable which we send to DownloadTask class to instruct it what to do
    //second - name of method which shows the progress of this task
    //third - variable which can be returned by DownloadTask class
    public class DownloadTask extends AsyncTask <String, Void, String>{

        //call execute method from DownloadTask class - will execute this method
        @Override
        protected String doInBackground(String... params) {

            String result ="";
            URL url;
            HttpURLConnection httpConnection = null;

            for(String param : params){
                Log.i("Test",param);
            }

            try{

                //create URL from string
                url=new URL(params[0]);

                //open HttpURLConnection with URL and openConnection() method
                httpConnection = (HttpURLConnection)url.openConnection();

                //open inputStream from HttpURLConnection with getInputStream() method
                 InputStream in = httpConnection.getInputStream();
                //read stream with InputStreamReader
                InputStreamReader reader = new InputStreamReader(in);

                int data = reader.read();

                //at the end of content data from stream - will be -1
                while(data!=-1){
                    char current = (char)data;
                    result+=current;

                    data= reader.read();
                }

                return result;
            }catch(Exception e){
                e.printStackTrace();

                return "Failed";
            }
            //call get() after execute() method - wil provide returned data
            //return result;
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        DownloadTask dTask = new DownloadTask();
        String result="";
        try {
            //result = dTask.execute("https://www.ecowebhosting.co.uk/").get();
            result = new DownloadTask().execute("https://www.ecowebhosting.co.uk/").get();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
        Log.i("Result",result);
    }
}
==================================================================


============DOWNLOAD IMAGE FROM WEB===============================
add to AndroidManifest.xml
<uses-permission android:name="android.permission.INTERNET"/>

create nested class DownloadTask extends AsyncTask <String, Void, Bitmap>
to process url and return image found on the url's location

next example of apps MainActivite class

package com.example.a.appdownloadimagefromweb;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.AsyncTask;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.ImageView;

import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.concurrent.ExecutionException;

public class MainActivity extends AppCompatActivity {

    ImageView downloadedImage;

    public void functionButtonDownloadImage(View view){

        //http://orig12.deviantart.net/6492/f/2016/059/3/4/seasonal_feathers_by_nanfe-d9tggn2.jpg
        Log.i("Test","Button 1 - clicked");

        ImageDownloader task = new ImageDownloader();
        Bitmap myImage;
        try {
            myImage = task.execute("http://orig12.deviantart.net/6492/f/2016/059/3/4/seasonal_feathers_by_nanfe-d9tggn2.jpg").get();

            downloadedImage.setImageBitmap(myImage);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        downloadedImage = (ImageView)findViewById(R.id.image1);
    }

    public class ImageDownloader extends AsyncTask<String,Void, Bitmap> {
        @Override
        protected Bitmap doInBackground(String... params) {

            try {
                URL url = new URL(params[0]);

                HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection();

                //get image in one go and convert to bitmap
                urlConnection.connect();

                InputStream in = urlConnection.getInputStream();

                Bitmap myBitmap = BitmapFactory.decodeStream(in);

                return myBitmap;
            } catch (MalformedURLException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return null;
        }
    }
}

===============TOAST FROM NON-UI THREAD=========
//to call Toast from non-UI thread
    public void errorToast(final String errorString) {
        Handler handler = new Handler(Looper.getMainLooper());

        handler.postDelayed(new Runnable() {

            @Override
            public void run() {
                Toast.makeText(getApplicationContext(), errorString, Toast.LENGTH_SHORT).show();
            }
        }, 1000);
    }


==============WEATHER APP==================

import android.content.Context;
import android.os.AsyncTask;
import android.os.Handler;
import android.os.Looper;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.inputmethod.InputMethodManager;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLEncoder;

public class MainActivity extends AppCompatActivity {
    //unsplash.com - free images for background
    EditText editCity;
    TextView textWeather;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        editCity = (EditText) findViewById(R.id.editTextCity);
        textWeather = (TextView) findViewById(R.id.textViewWeather);
    }

    private class DownloadWeatherTask extends AsyncTask<String, Void, String> {

        @Override
        protected String doInBackground(String... params) {
            StringBuilder result = new StringBuilder();

            try {
                URL url = new URL(params[0]);
                HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection();
                InputStream in = httpURLConnection.getInputStream();
                InputStreamReader reader = new InputStreamReader(in);
                int data = reader.read();

                while (data > -1) {
                    char current = (char) data;
                    result.append(current);
                    data = reader.read();
                }
                return result.toString();
            } catch (MalformedURLException e) {
                e.printStackTrace();
                Log.i("Connect", "MalformedURLException");
                //special method to draw toast because of exception if toast runs not on UI thread
                errorToast("Cant get weather: wrong city name");
            } catch (IOException e) {
                e.printStackTrace();
                Log.i("Connect", "IOException");
                errorToast("Cant get weather: wrong city name");
            }
            return null;
        }

        //executed on doInBackground() finish
        //string result = returned from doInBackground string result
        @Override
        protected void onPostExecute(String result) {
            super.onPostExecute(result);

            if (result != null) {
                Log.i("resultString", result);
                String weatherForTextField = "";
                try {
                    JSONObject jsonObject = new JSONObject(result);
                    String resultWeather = jsonObject.getString("weather");

                    JSONArray jsonArray = new JSONArray(resultWeather);
                    JSONObject tempJSON;
                    for (int i = 0; i < jsonArray.length(); i++) {
                        tempJSON = jsonArray.getJSONObject(i);
                        weatherForTextField += "Main: " + tempJSON.getString("main")
                                + "\nDescription: " + tempJSON.getString("description");
                    }

                    tempJSON = jsonObject.getJSONObject("main");
                    weatherForTextField += "\nTemp: " + kelvinToCelsius(tempJSON.getString("temp"))
                            + "\nPressure: " + tempJSON.getString("pressure")
                            + "\nHumidity: " + tempJSON.getString("humidity")
                            + "\nTemp_min: " + kelvinToCelsius(tempJSON.getString("temp_min"))
                            + "\nTemp_max: " + kelvinToCelsius(tempJSON.getString("temp_max"));

                    tempJSON= jsonObject.getJSONObject("coord");
                    weatherForTextField+="\nLon: " + tempJSON.getString("lon")
                            +"\nLat: "+tempJSON.getString("lat");


                    weatherForTextField+="\n"+jsonObject.getString("name");

                    textWeather.setText(weatherForTextField);
                } catch (JSONException e) {
                    textWeather.setText(noneInfo());
                    e.printStackTrace();
                }
            }else{
                textWeather.setText(noneInfo());
            }
        }
    }

    //to call Toast from non-UI thread
    public void errorToast(final String errorString) {
        Handler handler = new Handler(Looper.getMainLooper());

        handler.postDelayed(new Runnable() {

            @Override
            public void run() {
                Toast.makeText(getApplicationContext(), errorString, Toast.LENGTH_SHORT).show();
            }
        }, 1000);
    }

    public void functionGetWeather(View view) {
        String city = editCity.getText().toString();
        Log.i("city: ", city);
        //to encode string city name to proper url(to handle spaces in name etc)
        try {
            city= URLEncoder.encode(city,"UTF-8");
            Log.i("city encoded: ", city);
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        //to get rid out from screen keyboard (which can block way if proposes variants)
        InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
        imm.hideSoftInputFromWindow(editCity.getWindowToken(), 0);

        new DownloadWeatherTask().execute("http://api.openweathermap.org/data/2.5/weather?q=" + city + "&appid=aabddda8fca6982bdf6299a97f0f0100");
    }

    public String kelvinToCelsius(String temperature) {
        float temp = Float.parseFloat(temperature);
        temp = temp - 273.15F;
        return new String("" + Math.round(temp));
    }

    public String noneInfo(){
        return "Main: " + "none"
                + "\nDescription: " + "none"
                + "\nTemp: " + "none"
                + "\nPressure: " + "none"
                + "\nHumidity: " + "none"
                + "\nTemp_min: " + "none"
                + "\nTemp_max: " + "none";
    }
}


===============MAPS, SELF LOCATION=============
permission in AndroidManifest.xml for location

<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
(FINE_LOCATION - mean coords from GPS, we can define another LOCATION, not FINE, for  source like Wi-Fi if needed)

code for location get - first LocationManager - 
which take location from  getSystemServiceContext.LOCATION_SERVICE)
than - LocationListener which will check users location and give signal on change

than - check do we have explicit permission for location from user and ask it if haven't

//if no permission
if(ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)!= PackageManager.PERMISSION_GRANTED){
            //ask for it
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION}, 1);
}

than create method which will react on users responce on permission ask
@Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);

        //if we have responce and responce tell that we have permission
        if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {

            //here we need one more check if we do have permission
            if(ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)== PackageManager.PERMISSION_GRANTED){
            //if we do have permission - call requestLocationUpdates() method for locationManager
                //which will add listener to it, and give details for listener
                // LocationManager.GPS_PROVIDER - as location data provider(GPS because we choose ACCESS_FINE_LOCATION
                // 0 - for min time between ask on location changes - we can put some value to save battery, like to ask only every 10 seconds or more
                // 0 - for min distance of location change to give signal to method
                // locationListener
                locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, locationListener);
            }
        }
    }


full code of MainActivity
import android.Manifest;
import android.content.Context;
import android.content.pm.PackageManager;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.os.Build;
import android.support.annotation.NonNull;
import android.support.v4.app.ActivityCompat;
import android.support.v4.content.ContextCompat;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.util.Log;

public class MainActivity extends AppCompatActivity {

    LocationManager locationManager;
    LocationListener locationListener;

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);

        Log.i("request", "1");
        //if we have response and response tell that we have permission
        if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
            Log.i("request", "2");
            //here we need one more check if we do have permission
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
                Log.i("request", "3");
                //if we do have permission - call requestLocationUpdates() method for locationManager
                //which will add listener to it, and give details for listener
                // LocationManager.GPS_PROVIDER - as location data provider(GPS because we choose ACCESS_FINE_LOCATION
                // 0 - for min time between ask on location changes - we can put some value to save battery, like to ask only every 10 seconds or more
                // 0 - for min distance of location change to give signal to method
                // locationListener

                locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, locationListener);
            }
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        //get users location
        locationManager = (LocationManager) this.getSystemService(Context.LOCATION_SERVICE);
        Log.i("Location", locationManager.toString());
        locationListener = new LocationListener() {
            @Override
            public void onLocationChanged(Location location) {

                Log.i("Location1", location.toString());
            }

            @Override
            public void onStatusChanged(String provider, int status, Bundle extras) {

            }

            @Override
            public void onProviderEnabled(String provider) {

            }

            @Override
            public void onProviderDisabled(String provider) {

            }
        };

        //if device running SDK <23(Marshmallow)
        if (Build.VERSION.SDK_INT < 23) {
            Log.i("request", "6");
            locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, locationListener);
        } else {
            //we need to ask user permission for location explicitly
            //first check if we already have permission, call object ContextCompat -
            // Helper for accessing features in {@link android.content.Context}
            // introduced after API level 4 in a backwards compatible fashion.
            //invoke method checkSelfPermissions() which needs Context and permission name
            // Context - this, permission name - Manifest.permission.ACCESS_FINE_LOCATION
            //if no permission
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                Log.i("request", "4");
                //ask for it
                ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION}, 1);
            } else {
                Log.i("request", "5");
                locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, locationListener);
            }
        }
    }
}


====MAPS USER LOCATION MARKER CODE

import android.Manifest;
import android.content.pm.PackageManager;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.os.Build;
import android.support.annotation.NonNull;
import android.support.v4.app.ActivityCompat;
import android.support.v4.app.FragmentActivity;
import android.os.Bundle;
import android.support.v4.content.ContextCompat;
import android.util.Log;

import com.google.android.gms.maps.CameraUpdateFactory;
import com.google.android.gms.maps.GoogleMap;
import com.google.android.gms.maps.OnMapReadyCallback;
import com.google.android.gms.maps.SupportMapFragment;
import com.google.android.gms.maps.model.LatLng;
import com.google.android.gms.maps.model.MarkerOptions;

public class MapsActivity extends FragmentActivity implements OnMapReadyCallback {

    private GoogleMap mMap;
    private LocationManager locationManager;
    private LocationListener locationListener;
    double lat;
    double lon;

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
                locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, locationListener);
            }
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_maps);

        // Obtain the SupportMapFragment and get notified when the map is ready to be used.
        SupportMapFragment mapFragment = (SupportMapFragment) getSupportFragmentManager()
                .findFragmentById(R.id.map);
        mapFragment.getMapAsync(this);

    }


    /**
     * Manipulates the map once available.
     * This callback is triggered when the map is ready to be used.
     * This is where we can add markers or lines, add listeners or move the camera. In this case,
     * we just add a marker near Sydney, Australia.
     * If Google Play services is not installed on the device, the user will be prompted to install
     * it inside the SupportMapFragment. This method will only be triggered once the user has
     * installed Google Play services and returned to the app.
     */
    @Override
    public void onMapReady(GoogleMap googleMap) {
        mMap = googleMap;

        locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);


        locationListener = new LocationListener() {
            @Override
            public void onLocationChanged(Location location) {
                Log.i("Location: ", location.toString());
                //to draw marker on map on user move
                lat = location.getLatitude();
                lon = location.getLongitude();
                LatLng userLoc = new LatLng(lat, lon);
                mMap.addMarker(new MarkerOptions().position(userLoc).title("User-" + lat + ":lon"));
                mMap.moveCamera(CameraUpdateFactory.newLatLng(userLoc));
            }

            @Override
            public void onStatusChanged(String provider, int status, Bundle extras) {
            }

            @Override
            public void onProviderEnabled(String provider) {
            }

            @Override
            public void onProviderDisabled(String provider) {
            }
        };

        //if SDK < 23(Marshmallow) - we dont need permission and can ask location immediately
        if (Build.VERSION.SDK_INT < 23) {
            locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, locationListener);
            //if SDK > 23
        } else {
            //check do we have permission
            //if haven't - ask
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                //ask permission
                ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION}, 1);
            }//if have - run code to ask location
            else {
                locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, locationListener);

                //to draw marker on map on start, not only when user moves
                Location lastKnownLocation = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);

                lat = lastKnownLocation.getLatitude();
                lon = lastKnownLocation.getLongitude();
                LatLng userLoc = new LatLng(lat, lon);
                mMap.addMarker(new MarkerOptions().position(userLoc).title("User-lat:" + lat + ":lon" + lon));
                mMap.moveCamera(CameraUpdateFactory.newLatLng(userLoc));
            }
        }
    }
}



